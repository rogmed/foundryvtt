{"version":3,"file":"main.js","mappings":"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","sources":["webpack:///../common/Settings.ts","webpack:///./src/AngleSnaps.ts","webpack:///./src/LineToBoxCollision.ts","webpack:///./src/SnapIntersect.ts","webpack:///./src/SquareTemplate.ts","webpack:///./src/TemplateConfig.ts","webpack:///./src/TemplateTargeting.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///./src/df-templates.ts"],"sourcesContent":["\ndeclare global {\n\tinterface LenientGlobalVariableTypes {\n\t\tgame: never;\n\t\tcanvas: never;\n\t}\n\tinterface String {\n\t\t/** Localizes the string via the global `game.i18n.localize()` function. */\n\t\tlocalize(): string\n\t}\n\ttype AnyFunction = (...args: any) => any;\n}\n\nexport default class SETTINGS {\n\tstatic MOD_NAME: string;\n\tstatic init(moduleName: string) {\n\t\tthis.MOD_NAME = moduleName;\n\t\tif (!String.prototype.localize) {\n\t\t\tString.prototype.localize = function () {\n\t\t\t\treturn game.i18n.localize(this.valueOf());\n\t\t\t};\n\t\t}\n\t}\n\tstatic register<T>(key: string, config: ClientSettings.PartialSettingConfig<T>) { game.settings.register(SETTINGS.MOD_NAME, key, config); }\n\tstatic registerMenu(key: string, config: ClientSettings.PartialSettingSubmenuConfig) { game.settings.registerMenu(SETTINGS.MOD_NAME, key, config); }\n\tstatic get<T>(key: string): T { return <T>game.settings.get(SETTINGS.MOD_NAME, key); }\n\tstatic async set<T>(key: string, value: T): Promise<T> { return await game.settings.set(SETTINGS.MOD_NAME, key, value); }\n\tstatic default<T>(key: string): T { return <T>game.settings.settings.get(SETTINGS.MOD_NAME + '.' + key).default; }\n\t/** helper for referencing a Typed constructor for the `type` field of a setting { type: SETTINGS.typeOf<MyClass>() } */\n\tstatic typeOf<T>(): ConstructorOf<T> { return Object as any; }\n}\n","import SETTINGS from \"../../common/Settings\";\n\nexport default class AngleSnaps {\n\tstatic init() {\n\t\tSETTINGS.register<number>('angle-snap-macro', {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.AngleSnap.MacroName',\n\t\t\thint: 'DF_TEMPLATES.AngleSnap.MacroHint',\n\t\t\ttype: Number,\n\t\t\trange: {\n\t\t\t\tmin: 4,\n\t\t\t\tmax: 24,\n\t\t\t\tstep: 4\n\t\t\t},\n\t\t\tdefault: 24\n\t\t});\n\t\tSETTINGS.register<number>('angle-snap-micro', {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.AngleSnap.MicroName',\n\t\t\thint: 'DF_TEMPLATES.AngleSnap.MicroHint',\n\t\t\ttype: Number,\n\t\t\trange: {\n\t\t\t\tmin: 1,\n\t\t\t\tmax: 4,\n\t\t\t\tstep: 1\n\t\t\t},\n\t\t\tdefault: 3\n\t\t});\n\t}\n\n\tstatic ready() {\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'canvas.templates._onMouseWheel', function (this: TemplateLayer, event: MouseEvent): any {\n\t\t\t// Determine whether we have a hovered template?\n\t\t\tconst template = this.hover;\n\t\t\tif (!template) return;\n\t\t\t// Determine the incremental angle of rotation from event data\n\t\t\tconst snapCount = SETTINGS.get<number>('angle-snap-macro');\n\t\t\tlet snap = 360 / snapCount;\n\t\t\tif (!event.shiftKey)\n\t\t\t\tsnap /= SETTINGS.get<number>('angle-snap-micro');\n\n\t\t\tconst sign = Math.sign((event as any).deltaY);\n\t\t\tconst delta = snap * sign;\n\t\t\tlet direction = template.document.direction - (template.document.direction % snap);\n\t\t\tif (template.document.direction % snap !== 0 && sign < 0)\n\t\t\t\tdirection += snap;\n\t\t\treturn template.rotate(direction + delta, snap);\n\t\t}, 'OVERRIDE');\n\t}\n\n\tstatic handleDnD5eAbilityTemplate(this: any, event: any) {\n\t\t/***************** THIS IS COPIED FROM THE DnD 5e CODE BASE `AbilityTemplate.prototype._onRotatePlacement `module/canvas/ability-template.mjs`` ***************/\n\t\tif (event.ctrlKey) event.preventDefault(); // Avoid zooming the browser window\n\t\tevent.stopPropagation();\n\n\t\t/**** MODIFIED THIS REGION ****/\n\t\tconst snapCount = SETTINGS.get<number>('angle-snap-macro');\n\t\tlet snap = 360 / snapCount;\n\t\tif (event.shiftKey)\n\t\t\tsnap /= SETTINGS.get<number>('angle-snap-micro');\n\n\t\tconst sign = Math.sign(event.deltaY);\n\t\tlet direction = this.document.direction;\n\t\tif (direction < 0) direction += 360;\n\t\tdirection = direction - (direction % snap);\n\t\tif (this.document.direction % snap !== 0 && sign < 0)\n\t\t\tdirection += snap;\n\t\tthis.document.updateSource({ direction: direction + (snap * sign) });\n\t\t/**** END OF MODIFICATION ****/\n\n\t\tthis.refresh();\n\t\t/***************** END OF COPY ***************/\n\t}\n}","\n\nenum OutCode {\n\tINSIDE = 0x0000,\n\tLEFT = 0x0001,\n\tRIGHT = 0x0010,\n\tBOTTOM = 0x0100,\n\tTOP = 0x1000\n}\n/**\n * Uses the highly optimized Cohen–Sutherland algorithm for detecting if a line segment passes through a rectangle on a 2D plane.\n * https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm\n */\nexport default class LineToBoxCollision {\n\tprivate static _computeOutCode(x: number, y: number, bounds: { left: number, right: number, top: number, bottom: number }): OutCode {\n\t\tlet code: OutCode;\n\t\tcode = OutCode.INSIDE;          // initialised as being inside of [[clip window]]\n\t\tif (x <= bounds.left)           // to the left of clip window\n\t\t\tcode |= OutCode.LEFT;\n\t\telse if (x >= bounds.right)      // to the right of clip window\n\t\t\tcode |= OutCode.RIGHT;\n\t\tif (y <= bounds.top)           // below the clip window\n\t\t\tcode |= OutCode.BOTTOM;\n\t\telse if (y >= bounds.bottom)      // above the clip window\n\t\t\tcode |= OutCode.TOP;\n\t\treturn code;\n\t}\n\n\t// Cohen–Sutherland clipping algorithm clips a line from\n\t// P0 = (x0, y0) to P1 = (x1, y1) against a rectangle with \n\t// diagonal from (left, top) to (right, bottom).\n\tstatic cohenSutherlandLineClipAndDraw(x0: number, y0: number, x1: number, y1: number,\n\t\tbounds: { left: number, right: number, top: number, bottom: number }): boolean {\n\t\t// compute outcodes for P0, P1, and whatever point lies outside the clip rectangle\n\t\tlet outcode0: OutCode = this._computeOutCode(x0, y0, bounds);\n\t\tlet outcode1: OutCode = this._computeOutCode(x1, y1, bounds);\n\t\tlet accept = false;\n\n\t\twhile (true) {\n\t\t\tif (!(outcode0 | outcode1)) {\n\t\t\t\t// bitwise OR is 0: both points inside window; trivially accept and exit loop\n\t\t\t\taccept = true;\n\t\t\t\tbreak;\n\t\t\t} else if (outcode0 & outcode1) {\n\t\t\t\t// bitwise AND is not 0: both points share an outside zone (LEFT, RIGHT, TOP,\n\t\t\t\t// or BOTTOM), so both must be outside window; exit loop (accept is false)\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\t// failed both tests, so calculate the line segment to clip\n\t\t\t\t// from an outside point to an intersection with clip edge\n\t\t\t\tlet [x, y] = [0, 0];\n\n\t\t\t\t// At least one endpoint is outside the clip rectangle; pick it.\n\t\t\t\tconst outcodeOut: OutCode = outcode1 > outcode0 ? outcode1 : outcode0;\n\n\t\t\t\t// Now find the intersection point;\n\t\t\t\t// use formulas:\n\t\t\t\t//   slope = (y1 - y0) / (x1 - x0)\n\t\t\t\t//   x = x0 + (1 / slope) * (ym - y0), where ym is top or bottom\n\t\t\t\t//   y = y0 + slope * (xm - x0), where xm is left or right\n\t\t\t\t// No need to worry about divide-by-zero because, in each case, the\n\t\t\t\t// outcode bit being tested guarantees the denominator is non-zero\n\t\t\t\tif (outcodeOut & OutCode.TOP) {           // point is above the clip window\n\t\t\t\t\tx = x0 + (x1 - x0) * (bounds.bottom - y0) / (y1 - y0);\n\t\t\t\t\ty = bounds.bottom - 1;\n\t\t\t\t} else if (outcodeOut & OutCode.BOTTOM) { // point is below the clip window\n\t\t\t\t\tx = x0 + (x1 - x0) * (bounds.top - y0) / (y1 - y0);\n\t\t\t\t\ty = bounds.top + 1;\n\t\t\t\t} else if (outcodeOut & OutCode.RIGHT) {  // point is to the right of clip window\n\t\t\t\t\ty = y0 + (y1 - y0) * (bounds.right - x0) / (x1 - x0);\n\t\t\t\t\tx = bounds.right - 1;\n\t\t\t\t} else if (outcodeOut & OutCode.LEFT) {   // point is to the left of clip window\n\t\t\t\t\ty = y0 + (y1 - y0) * (bounds.left - x0) / (x1 - x0);\n\t\t\t\t\tx = bounds.left + 1;\n\t\t\t\t}\n\n\t\t\t\t// Now we move outside point to intersection point to clip\n\t\t\t\t// and get ready for next pass.\n\t\t\t\tif (outcodeOut == outcode0) {\n\t\t\t\t\tx0 = x;\n\t\t\t\t\ty0 = y;\n\t\t\t\t\toutcode0 = this._computeOutCode(x0, y0, bounds);\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x;\n\t\t\t\t\ty1 = y;\n\t\t\t\t\toutcode1 = this._computeOutCode(x1, y1, bounds);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn accept;\n\t}\n}","import SETTINGS from \"../../common/Settings\";\n\nexport default class SnapIntersect {\n\tstatic init() {\n\t\tSETTINGS.register('SnapIntersect', {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.SnapIntersectName',\n\t\t\thint: 'DF_TEMPLATES.SnapIntersectHint',\n\t\t\ttype: Boolean,\n\t\t\tdefault: false,\n\t\t\tonChange: (toggled) => toggled ? this.patch() : this.unpatch()\n\t\t});\n\t}\n\n\tstatic ready() {\n\t\tif (SETTINGS.get<boolean>('SnapIntersect'))\n\t\t\tthis.patch();\n\t}\n\n\tprivate static patch() {\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'canvas.templates.gridPrecision', SnapIntersect.TemplateLayer_gridPrecision, 'OVERRIDE');\n\t}\n\tprivate static unpatch() {\n\t\tlibWrapper.unregister(SETTINGS.MOD_NAME, 'canvas.templates.gridPrecision', false);\n\t}\n\n\tprivate static TemplateLayer_gridPrecision() {\n\t\treturn canvas.grid.type === CONST.GRID_TYPES.GRIDLESS ? 0 : 1;\n\t}\n\n\tstatic handleDnD5eAbilityTemplate(this: any, event: any) {\n\t\t/***************** THIS IS COPIED FROM THE DnD 5e CODE BASE `AbilityTemplate.prototype._onMovePlacement` `module/canvas/ability-template.mjs` ***************/\n\t\tconst now = Date.now(); // Apply a 20ms throttle\n\t\tif ( now - this._moveTime <= 20 ) return;\n\t\tconst center = event.data.getLocalPosition(this.layer);\n\t\t/**** MODIFIED THIS `getSnappedPosition` TO HAVE INTERVAL 1 INSTEAD OF 2 IF ENABLED ****/\n\t\tconst snapped = canvas.grid.getSnappedPosition(center.x, center.y, SETTINGS.get('SnapIntersect') ? 1 : 2);\n\t\tthis.document.updateSource({x: snapped.x, y: snapped.y});\n\t\tthis.refresh();\n\t\tthis._moveTime = now;\n\t\t/***************** END OF COPY ***************/\n\t}\n}","import SETTINGS from \"../../common/Settings\";\n\nexport default class SquareTemplate {\n\tstatic readonly FIX_ROTATION_PREF = 'fix-square-rotation';\n\n\tstatic init() {\n\t\tSETTINGS.register(SquareTemplate.FIX_ROTATION_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.SquareRotateName',\n\t\t\thint: 'DF_TEMPLATES.SquareRotateHint',\n\t\t\ttype: Boolean,\n\t\t\tdefault: true,\n\t\t\tonChange: (toggled) => toggled ? SquareTemplate.patch() : SquareTemplate.unpatch()\n\t\t});\n\t\tif (SETTINGS.get(SquareTemplate.FIX_ROTATION_PREF))\n\t\t\tSquareTemplate.patch();\n\t}\n\n\tprivate static patch() {\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype._getRectShape', SquareTemplate.MeasuredTemplate_getRectShape, 'OVERRIDE');\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype._refreshRulerText', SquareTemplate.MeasuredTemplate_refreshRulerText, 'WRAPPER');\n\t}\n\tprivate static unpatch() {\n\t\tlibWrapper.unregister(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype._getRectShape', false);\n\t\tlibWrapper.unregister(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype._refreshRulerText', false);\n\t}\n\n\tstatic MeasuredTemplate_getRectShape(this: MeasuredTemplate, direction: number, distance: number, adjustForRoundingError = false): PIXI.Polygon {\n\t\t// Generate a rotation matrix to apply the rect against. The base rotation must be rotated\n\t\t// CCW by 45° before applying the real direction rotation.\n\t\tconst matrix = PIXI.Matrix.IDENTITY.rotate((-45 * (Math.PI / 180)) + direction);\n\t\t// If the shape will be used for collision, shrink the rectangle by a fixed EPSILON amount to account for rounding errors\n\t\tconst EPSILON = adjustForRoundingError ? 0.0001 : 0;\n\t\t// Use simple Pythagoras to calculate the square's size from the diagonal \"distance\".\n\t\tconst size = Math.sqrt((distance * distance) / 2) - EPSILON;\n\t\t// Create the square's 4 corners with origin being the Top-Left corner and apply the\n\t\t// rotation matrix against each.\n\t\tconst topLeft = matrix.apply(new PIXI.Point(EPSILON, EPSILON));\n\t\tconst topRight = matrix.apply(new PIXI.Point(size, EPSILON));\n\t\tconst botLeft = matrix.apply(new PIXI.Point(EPSILON, size));\n\t\tconst botRight = matrix.apply(new PIXI.Point(size, size));\n\t\t// Inject the vector data into a Polygon object to create a closed shape.\n\t\tconst shape = <any>new PIXI.Polygon([topLeft.x, topLeft.y, topRight.x, topRight.y, botRight.x, botRight.y, botLeft.x, botLeft.y, topLeft.x, topLeft.y]);\n\t\t// Add these fields so that the Sequencer mod doesn't have a stroke lol\n\t\tshape.x = topLeft.x;\n\t\tshape.y = topLeft.y;\n\t\tshape.width = size;\n\t\tshape.height = size;\n\t\treturn <PIXI.Polygon>shape;\n\t}\n\n\tprivate static MeasuredTemplate_refreshRulerText(this: MeasuredTemplate, wrapped: () => void): void {\n\t\twrapped();\n\t\t// Overwrite the text for the \"rect\" type\n\t\tif (this.document.t === \"rect\") {\n\t\t\t// Use simple Pythagoras to calculate the square's size from the diagonal \"distance\".\n\t\t\tconst size = Math.sqrt((this.document.distance * this.document.distance) / 2).toFixed(1);\n\t\t\tconst text = `${size}${canvas.scene.grid.units}`;\n\t\t\t(<any>this).ruler.text = text;\n\t\t}\n\t}\n}","import SETTINGS from \"../../common/Settings\";\n\n\ninterface Option {\n\ttype?: string;\n\tlabel: string;\n\tdesc: string;\n}\n\ninterface Config {\n\tcircle: string;\n\tcone: string;\n\trect: string;\n\tray: string;\n}\n\ninterface Data extends Config {\n\toptions: Option[];\n}\n\nexport enum HighlightMode {\n\tCENTER = 'center',\n\tTOUCH = 'touch',\n\tPOINTS = 'points'\n}\n\nexport class TemplateConfig extends FormApplication<any, Data> {\n\tprivate static readonly CONFIG_PREF = 'template-config';\n\tprivate static readonly PATCH_5E_PREF = \"template-targeting-patch5e\";\n\tprivate static readonly PATCH_5E_CIRCLE_PREF = \"template-targeting-patch5e-circle\";\n\tprivate static _options: Option[];\n\tprivate static get options(): Option[] {\n\t\tif (!this._options) {\n\t\t\tconst root: Record<string, Option> =\n\t\t\t\t<any>(game.i18n.translations['DF_TEMPLATES'] ?? (game.i18n as any)._fallback['DF_TEMPLATES'])['TemplateConfig']['Options'];\n\t\t\tthis._options = Object.keys(root).map(key => {\n\t\t\t\troot[key].type = key;\n\t\t\t\treturn root[key];\n\t\t\t});\n\t\t}\n\t\treturn this._options;\n\t}\n\n\tstatic get defaultOptions(): FormApplicationOptions {\n\t\tconst options = mergeObject(super.defaultOptions, {\n\t\t\tresizable: false,\n\t\t\tsubmitOnChange: false,\n\t\t\tcloseOnSubmit: true,\n\t\t\teditable: true,\n\t\t\tsubmitOnClose: false,\n\t\t\twidth: 500,\n\t\t\tpopOut: true,\n\t\t\tminimizable: false,\n\t\t\ttitle: 'DF_TEMPLATES.TemplateConfig.Title',\n\t\t\ttemplate: 'modules/df-templates/templates/template-config.hbs'\n\t\t});\n\t\treturn options;\n\t}\n\n\tstatic get config(): Config { return SETTINGS.get(this.CONFIG_PREF); }\n\tstatic get isNotDefault(): boolean {\n\t\tconst config = this.config;\n\t\treturn config.circle !== HighlightMode.CENTER\n\t\t\t|| config.cone !== HighlightMode.CENTER\n\t\t\t|| config.rect !== HighlightMode.CENTER\n\t\t\t|| config.ray !== HighlightMode.CENTER;\n\t}\n\n\tstatic init() {\n\t\tSETTINGS.register(this.PATCH_5E_PREF, {\n\t\t\tconfig: false,\n\t\t\ttype: Boolean,\n\t\t\tdefault: false,\n\t\t\tscope: 'world'\n\t\t});\n\t\tSETTINGS.register(this.PATCH_5E_CIRCLE_PREF, {\n\t\t\tconfig: false,\n\t\t\ttype: Boolean,\n\t\t\tdefault: false,\n\t\t\tscope: 'world'\n\t\t});\n\n\t\tconst old5ePatch = SETTINGS.get<boolean>(this.PATCH_5E_PREF);\n\t\tconst old5eCirclePatch = SETTINGS.get<boolean>(this.PATCH_5E_CIRCLE_PREF);\n\n\t\tSETTINGS.register<Config>(this.CONFIG_PREF, {\n\t\t\tconfig: false,\n\t\t\tscope: 'world',\n\t\t\ttype: <any>Object,\n\t\t\tdefault: {\n\t\t\t\tcircle: old5eCirclePatch ? HighlightMode.TOUCH : HighlightMode.CENTER,\n\t\t\t\tcone: old5ePatch ? HighlightMode.TOUCH : HighlightMode.CENTER,\n\t\t\t\trect: old5ePatch ? HighlightMode.TOUCH : HighlightMode.CENTER,\n\t\t\t\tray: old5ePatch ? HighlightMode.TOUCH : HighlightMode.CENTER\n\t\t\t},\n\t\t\tonChange: () => canvas.templates?.placeables.filter((t: MeasuredTemplate) => t.document.t === \"circle\")\n\t\t\t\t.forEach((t: MeasuredTemplate) => t.draw())\n\t\t});\n\n\t\tSETTINGS.registerMenu('template-config', {\n\t\t\trestricted: true,\n\t\t\ttype: <any>TemplateConfig,\n\t\t\tlabel: \"DF_TEMPLATES.TemplateConfig.Title\"\n\t\t});\n\t}\n\n\tgetData(_options?: Partial<any>): Data | Promise<Data> {\n\t\tconst data = mergeObject(TemplateConfig.config, {\n\t\t\toptions: TemplateConfig.options\n\t\t});\n\t\treturn data;\n\t}\n\n\tactivateListeners(html: JQuery<HTMLElement>): void {\n\t\thtml.find('#dfte-set-foundry').on('click', e => {\n\t\t\te.preventDefault();\n\t\t\thtml.find(`select[name=\"circle\"]`).val(HighlightMode.CENTER);\n\t\t\thtml.find(`select[name=\"cone\"]`).val(HighlightMode.CENTER);\n\t\t\thtml.find(`select[name=\"rect\"]`).val(HighlightMode.CENTER);\n\t\t\thtml.find(`select[name=\"ray\"]`).val(HighlightMode.CENTER);\n\t\t});\n\t\thtml.find('#dfte-set-dnd5e').on('click', e => {\n\t\t\te.preventDefault();\n\t\t\thtml.find(`select[name=\"circle\"]`).val(HighlightMode.CENTER);\n\t\t\thtml.find(`select[name=\"cone\"]`).val(HighlightMode.TOUCH);\n\t\t\thtml.find(`select[name=\"rect\"]`).val(HighlightMode.TOUCH);\n\t\t\thtml.find(`select[name=\"ray\"]`).val(HighlightMode.TOUCH);\n\t\t});\n\t\thtml.find('#cancel').on('click', e => {\n\t\t\te.preventDefault();\n\t\t\tthis.close();\n\t\t});\n\t}\n\n\tprotected async _updateObject(_event: Event, formData?: any): Promise<void> {\n\t\tawait SETTINGS.set(TemplateConfig.CONFIG_PREF, formData);\n\t}\n}","import SETTINGS from \"../../common/Settings\";\nimport LineToBoxCollision from \"./LineToBoxCollision\";\nimport { TemplateConfig, HighlightMode } from \"./TemplateConfig\";\n\nfunction throttle<T>(fn: AnyFunction, threshhold?: number): T {\n\tthreshhold || (threshhold = 250);\n\tlet last: number;\n\tlet hasTimer = false;\n\tlet mostRecent: any[];\n\treturn <any>function (this: any, ...args: any) {\n\t\t// Preserve the most recent arguments\n\t\tmostRecent = [...args];\n\t\t// Grab the current time\n\t\tconst now = +new Date;\n\t\tconst context = this;\n\t\t// If we have been called before, and we are within the timeout period\n\t\tif (last && now < last + threshhold) {\n\t\t\t// If we already have a timer set, return immediately\n\t\t\tif (hasTimer) return;\n\t\t\t// Create a timeout with the delta from `now` to end of `last + threshold`\n\t\t\thasTimer = true;\n\t\t\tsetTimeout(function () {\n\t\t\t\t// Unset the timer\n\t\t\t\thasTimer = false;\n\t\t\t\t// Update last invocation time\n\t\t\t\tlast = +new Date;\n\t\t\t\t// Invoke the original function\n\t\t\t\tfn.apply(context, mostRecent);\n\t\t\t}, threshhold - (now - last));\n\t\t}\n\t\t// This is the first time we've been called\n\t\telse {\n\t\t\t// Set the last time value\n\t\t\tlast = now;\n\t\t\t// Invoke the original function\n\t\t\tfn.apply(context, mostRecent);\n\t\t}\n\t};\n}\n\nexport default class TemplateTargeting {\n\n\tprivate static readonly PREVIEW_PREF = \"template-preview\";\n\tprivate static readonly TARGETING_TOGGLE_PREF = \"template-targeting-toggle\";\n\tprivate static readonly TARGETING_MODE_PREF = \"template-targeting\";\n\tprivate static readonly GRIDLESS_RESOLUTION_PREF = \"template-gridless-resolution\";\n\tprivate static readonly GRIDLESS_PERCENTAGE_PREF = \"template-gridless-percentage\";\n\n\tprivate static readonly PointGraphContainer = new PIXI.Graphics();\n\n\tstatic init() {\n\t\tTemplateConfig.init();\n\n\t\tSETTINGS.register(TemplateTargeting.TARGETING_TOGGLE_PREF, {\n\t\t\tconfig: false,\n\t\t\tscope: 'client',\n\t\t\ttype: Boolean,\n\t\t\tdefault: true,\n\t\t\tonChange: () => { if (SETTINGS.get(TemplateTargeting.TARGETING_MODE_PREF) !== 'toggle') return; }\n\t\t});\n\t\tSETTINGS.register<string>(TemplateTargeting.TARGETING_MODE_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.AutoTargetName',\n\t\t\thint: 'DF_TEMPLATES.AutoTargetHint',\n\t\t\ttype: String,\n\t\t\tchoices: {\n\t\t\t\tnever: 'Never',\n\t\t\t\ttoggle: 'Toggle (Add toggle button)',\n\t\t\t\talways: 'Always'\n\t\t\t},\n\t\t\tdefault: 'toggle',\n\t\t\tonChange: () => { ui.controls.initialize(); ui.controls.render(true); }\n\t\t});\n\t\tSETTINGS.register<number>(TemplateTargeting.GRIDLESS_RESOLUTION_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.GridlessPointResolutionName',\n\t\t\thint: 'DF_TEMPLATES.GridlessPointResolutionHint',\n\t\t\trange: {\n\t\t\t\tmax: 10,\n\t\t\t\tmin: 1,\n\t\t\t\tstep: 1\n\t\t\t},\n\t\t\ttype: Number,\n\t\t\tdefault: 3\n\t\t});\n\t\tSETTINGS.register<number>(TemplateTargeting.GRIDLESS_PERCENTAGE_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.GridlessPointPercentageName',\n\t\t\thint: 'DF_TEMPLATES.GridlessPointPercentageHint',\n\t\t\trange: {\n\t\t\t\tmax: 100,\n\t\t\t\tmin: 0,\n\t\t\t\tstep: 10\n\t\t\t},\n\t\t\ttype: Number,\n\t\t\tdefault: 0\n\t\t});\n\t\tSETTINGS.register(TemplateTargeting.PREVIEW_PREF, {\n\t\t\tconfig: true,\n\t\t\tscope: 'world',\n\t\t\tname: 'DF_TEMPLATES.PreviewName',\n\t\t\thint: 'DF_TEMPLATES.PreviewHint',\n\t\t\ttype: Boolean,\n\t\t\tdefault: true\n\t\t});\n\t\tHooks.on('getSceneControlButtons', (controls: SceneControl[]) => {\n\t\t\tif (SETTINGS.get(TemplateTargeting.TARGETING_MODE_PREF) !== 'toggle') return;\n\t\t\tconst control = controls.find(x => x.name === 'measure');\n\t\t\tcontrol.tools.splice(0, 0, {\n\t\t\t\ticon: 'fas fa-bullseye',\n\t\t\t\tname: 'autoTarget',\n\t\t\t\ttitle: 'DF_TEMPLATES.ToggleTitle',\n\t\t\t\tvisible: true,\n\t\t\t\ttoggle: true,\n\t\t\t\tactive: SETTINGS.get(TemplateTargeting.TARGETING_TOGGLE_PREF),\n\t\t\t\tonClick: (toggled: boolean) => { SETTINGS.set(TemplateTargeting.TARGETING_TOGGLE_PREF, toggled); }\n\t\t\t});\n\t\t});\n\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype.highlightGrid', this._MeasuredTemplate_highlightGrid, 'OVERRIDE');\n\t\t// When dragging a template, we need to catch the cancellation in order for us to refresh the template to draw back in its original position.\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'PlaceableObject.prototype._createInteractionManager', function (this: PlaceableObject, wrapper: () => MouseInteractionManager) {\n\t\t\tif (!(this instanceof MeasuredTemplate)) return wrapper();\n\t\t\t// We wrap the interaction manager construction method\n\t\t\tconst manager = wrapper();\n\t\t\t// Replacing the `dragLeftCancel` with our own wrapper function\n\t\t\tmanager.callbacks.dragLeftCancel = function (this: PlaceableObject, event: any) {\n\t\t\t\tthis.refresh();\n\t\t\t\tPlaceableObject.prototype._onDragLeftCancel.apply(this, [event]);\n\t\t\t};\n\t\t\treturn manager;\n\t\t}, 'WRAPPER');\n\t}\n\n\tstatic ready() {\n\t\t// This is used to throttle the number of UI updates made to a set number of Frames Per Second.\n\t\tconst ThrottledTemplateRefresh = throttle<(w?: AnyFunction) => void>(function (this: MeasuredTemplate) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\t\t\tTemplateTargeting._MeasuredTemplate_highlightGrid.apply(this);\n\t\t}, 1000 / 20);// Throttle to 20fps\n\n\t\t// Register for the D&D5e Ability Template preview\n\t\t// @ts-ignore\n\t\tif (game.dnd5e) {\n\t\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'game.dnd5e.canvas.AbilityTemplate.prototype.refresh', function (this: MeasuredTemplate, wrapper: AnyFunction, ...args: any) {\n\t\t\t\tThrottledTemplateRefresh.apply(this);\n\t\t\t\treturn wrapper(...args);\n\t\t\t}, 'WRAPPER');\n\t\t}\n\t\t// Register for the regular template movement preview\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'MeasuredTemplate.prototype.refresh', function (this: MeasuredTemplate, wrapper: AnyFunction) {\n\t\t\tThrottledTemplateRefresh.apply(this);\n\t\t\treturn wrapper();\n\t\t\t// return wrapper();\n\t\t}, 'WRAPPER');\n\n\t\t// Register for the regular template creation completion and cancellation\n\t\tconst handleTemplateCreation = function (this: TemplateLayer, wrapper: AnyFunction, ...args: any) {\n\t\t\t// clear the highlight preview layer\n\t\t\tcanvas.grid.getHighlightLayer('Template.null')?.clear();\n\t\t\treturn wrapper(...args);\n\t\t};\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'TemplateLayer.prototype._onDragLeftDrop', handleTemplateCreation, 'WRAPPER');\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'TemplateLayer.prototype._onDragLeftCancel', handleTemplateCreation, 'WRAPPER');\n\n\t\t// Add the point graph container to the controls layer for rendering\n\t\tcanvas.controls.addChild(TemplateTargeting.PointGraphContainer);\n\t}\n\n\tprivate static _MeasuredTemplate_highlightGrid(this: MeasuredTemplate) {\n\t\tconst mode = SETTINGS.get<string>(TemplateTargeting.TARGETING_MODE_PREF);\n\t\tconst shouldAutoSelect = mode === 'always' || (mode === 'toggle' && SETTINGS.get<boolean>(TemplateTargeting.TARGETING_TOGGLE_PREF));\n\t\tconst isOwner = this.document.user.id === game.userId;\n\t\t// Release all previously targeted tokens\n\t\tif ((this.hover || !this.id) && isOwner && shouldAutoSelect && canvas.tokens.objects) {\n\t\t\tfor (const t of game.user.targets) {\n\t\t\t\tt.setTarget(false, { releaseOthers: false, groupSelection: true });\n\t\t\t}\n\t\t}\n\t\tTemplateTargeting._handleTouchTemplate.bind(this)(isOwner, shouldAutoSelect);\n\t}\n\n\tprivate static _calculateGridTestArea(this: MeasuredTemplate) {\n\t\tconst shape: {\n\t\t\tradius?: number,\n\t\t\tpoints?: number[],\n\t\t\tx?: number,\n\t\t\ty?: number,\n\t\t\twidth?: number,\n\t\t\theight?: number\n\t\t} = <any>this.shape;\n\t\tconst points: number[] = shape.points ? shape.points :\n\t\t\t(shape.radius ?\n\t\t\t\t[-shape.radius, -shape.radius, shape.radius, shape.radius] :\n\t\t\t\t[shape.x, shape.y, shape.x + shape.width, shape.y + shape.height]);\n\t\tconst shapeBounds = {\n\t\t\tleft: Number.MAX_VALUE, right: Number.MIN_VALUE,\n\t\t\ttop: Number.MAX_VALUE, bottom: Number.MIN_VALUE,\n\t\t\twidth: function () { return this.right - this.left; },\n\t\t\theight: function () { return this.bottom - this.top; }\n\t\t};\n\t\tfor (let c = 0; c < points.length; c += 2) {\n\t\t\tif (points[c] < shapeBounds.left) shapeBounds.left = points[c];\n\t\t\tif (points[c] > shapeBounds.right) shapeBounds.right = points[c];\n\t\t\tif (points[c + 1] < shapeBounds.top) shapeBounds.top = points[c + 1];\n\t\t\tif (points[c + 1] > shapeBounds.bottom) shapeBounds.bottom = points[c + 1];\n\t\t}\n\t\tconst snappedTopLeft = canvas.grid.grid.getSnappedPosition(shapeBounds.left, shapeBounds.top, 1);\n\t\tconst snappedBottomRight = canvas.grid.grid.getSnappedPosition(shapeBounds.right, shapeBounds.bottom, 1);\n\t\t[shapeBounds.left, shapeBounds.top] = [snappedTopLeft.x, snappedTopLeft.y];\n\t\t[shapeBounds.right, shapeBounds.bottom] = [snappedBottomRight.x, snappedBottomRight.y];\n\t\treturn shapeBounds;\n\t}\n\n\tprivate static _handleTouchTemplate(this: MeasuredTemplate, isOwner: boolean, shouldAutoSelect: boolean) {\n\t\t/************** THIS CODE IS DIRECTLY COPIED FROM 'MeasuredTemplate.prototype.highlightGrid' ****************/\n\t\tconst grid = canvas.grid;\n\t\tconst d = canvas.dimensions;\n\t\tconst border = <number>this.borderColor;\n\t\tconst color = <number>this.fillColor;\n\t\tconst DEBUG = SETTINGS.get('template-debug');\n\n\t\t// Only highlight for objects which have a defined shape\n\t\tconst id: string = this.highlightId ?? (<any>this)['_original']?.highlightId;\n\t\tif ((!this.id && !SETTINGS.get(TemplateTargeting.PREVIEW_PREF)) || !this.shape) return;\n\n\t\t// Clear existing highlight\n\t\tconst hl = grid.getHighlightLayer(id);\n\t\thl?.clear();\n\n\t\t// If we are in gridless mode, highlight the shape directly\n\t\tif (grid.type === CONST.GRID_TYPES.GRIDLESS) {\n\t\t\tconst shape = this.shape.clone();\n\t\t\t//* ADDED CODE: This try-catch was added to handle a random error that occurs where\n\t\t\t//* Foundry Core tries to update the MeasuredTemplate when it doesn't have a position.\n\t\t\ttry {\n\t\t\t\tif (\"points\" in shape) {\n\t\t\t\t\tshape.points = shape.points.map((p, i) => {\n\t\t\t\t\t\tif (i % 2) return this.y + p;\n\t\t\t\t\t\telse return this.x + p;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tshape.x += this.x;\n\t\t\t\t\tshape.y += this.y;\n\t\t\t\t}\n\t\t\t}// eslint-disable-next-line no-empty\n\t\t\tcatch (error) { }\n\t\t\tgrid.grid.highlightGridPosition(hl, { border, color: <any>color, shape: <any>shape });\n\t\t\tTemplateTargeting._selectTokensByPointContainment.bind(this)(isOwner, shouldAutoSelect, this, <PIXI.Polygon>this.shape, true);\n\t\t\treturn;\n\t\t}\n\n\t\t// Get number of rows and columns\n\t\tconst shapeBounds = TemplateTargeting._calculateGridTestArea.apply(this);\n\t\tconst colCount = Math.ceil(shapeBounds.width() / grid.w) + 2; //? Add a padding ring around for any outlier cases\n\t\tconst rowCount = Math.ceil(shapeBounds.height() / grid.h) + 2; //? Add a padding ring around for any outlier cases\n\n\t\t// Get the offset of the template origin relative to the top-left grid space\n\t\tconst [tx, ty] = canvas.grid.getTopLeft(this.document.x, this.document.y);\n\t\tconst [row0, col0] = grid.grid.getGridPositionFromPixels(shapeBounds.left + tx, shapeBounds.top + ty);\n\t\tconst hx = canvas.grid.w / 2;\n\t\tconst hy = canvas.grid.h / 2;\n\n\t\t/***** START OF CODE EDIT *****/\n\t\t// Extract and prepare data\n\t\tlet { direction, distance, angle, width } = this.document;\n\t\tdistance *= (d.size / d.distance);\n\t\twidth *= (d.size / d.distance);\n\t\tangle = Math.toRadians(angle);\n\t\tdirection = Math.toRadians((direction % 360) + 360);\n\t\t// If we are round, the side is of length `distance`, otherwise calculate the true length of the hypotenouse\n\t\tconst isRound = game.settings.get(\"core\", \"coneTemplateType\") === 'round';\n\t\tconst rayLength = isRound ? distance : (distance / Math.sin((Math.PI / 2) - (angle / 2))) * Math.sin(Math.PI / 2);\n\n\t\tlet [ax1, ay1, bx1, by1] = [0, 0, 0, 0];\n\t\tlet [ax2, ay2, bx2, by2] = [0, 0, 0, 0];\n\t\tlet coneInitialized = false;\n\t\tconst generateConeData = () => {\n\t\t\tif (coneInitialized) return;\n\t\t\tconeInitialized = true;\n\t\t\t[ax1, ay1, bx1, by1] = [\n\t\t\t\tthis.document.x,\n\t\t\t\tthis.document.y,\n\t\t\t\tthis.document.x + (Math.cos(direction - (angle / 2)) * rayLength),\n\t\t\t\tthis.document.y + (Math.sin(direction - (angle / 2)) * rayLength)\n\t\t\t];\n\t\t\t[ax2, ay2, bx2, by2] = [\n\t\t\t\tthis.document.x,\n\t\t\t\tthis.document.y,\n\t\t\t\tthis.document.x + (Math.cos(direction + (angle / 2)) * rayLength),\n\t\t\t\tthis.document.y + (Math.sin(direction + (angle / 2)) * rayLength)\n\t\t\t];\n\t\t};\n\t\tconst generateRayData = () => {\n\t\t\tif (coneInitialized) return;\n\t\t\t[ax1, ay1] = [\n\t\t\t\tthis.document.x + (Math.cos(direction - (Math.PI / 2)) * (width / 2)),\n\t\t\t\tthis.document.y + (Math.sin(direction - (Math.PI / 2)) * (width / 2))\n\t\t\t];\n\t\t\t[bx1, by1] = [\n\t\t\t\tax1 + (Math.cos(direction) * distance),\n\t\t\t\tay1 + (Math.sin(direction) * distance)\n\t\t\t];\n\t\t\t[ax2, ay2] = [\n\t\t\t\tthis.document.x + (Math.cos(direction + (Math.PI / 2)) * (width / 2)),\n\t\t\t\tthis.document.y + (Math.sin(direction + (Math.PI / 2)) * (width / 2))\n\t\t\t];\n\t\t\t[bx2, by2] = [\n\t\t\t\tax2 + (Math.cos(direction) * distance),\n\t\t\t\tay2 + (Math.sin(direction) * distance)\n\t\t\t];\n\t\t};\n\t\t// Identify grid coordinates covered by the template Graphics\n\t\t//? Start on -1 to account for padding ring of cells around test area\n\t\tfor (let r = -1; r < rowCount; r++) {\n\t\t\t//? Start on -1 to account for padding ring of cells around test area\n\t\t\tfor (let c = -1; c < colCount; c++) {\n\t\t\t\tconst [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(row0 + r, col0 + c);\n\t\t\t\tconst testX = gx + hx;\n\t\t\t\tconst testY = gy + hy;\n\t\t\t\tconst testRect = new PIXI.Rectangle(gx, gy, canvas.grid.w, canvas.grid.h).normalize();\n\t\t\t\tlet contains = false;\n\t\t\t\tswitch (this.document.t) {\n\t\t\t\t\tcase \"circle\": {\n\t\t\t\t\t\t// Calculate the vector from the PoI to the grid square center\n\t\t\t\t\t\tconst [rcx, rcy] = [testX - this.document.x, testY - this.document.y];\n\t\t\t\t\t\t// If the distance between the centres is <= the circle's radius\n\t\t\t\t\t\tcontains = ((rcx * rcx) + (rcy * rcy)) <= (distance * distance);\n\t\t\t\t\t\tif (contains || TemplateConfig.config.circle === HighlightMode.CENTER) break;\n\n\t\t\t\t\t\tconst sqrDistance = distance * distance;\n\t\t\t\t\t\tlet [vx, vy] = [0, 0];\n\t\t\t\t\t\tconst testPoint = (x: number, y: number) => {\n\t\t\t\t\t\t\t[vx, vy] = [x - this.document.x, y - this.document.y];\n\t\t\t\t\t\t\treturn (vx * vx + vy * vy) < sqrDistance;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tcontains = testPoint(testRect.left, testRect.top)\n\t\t\t\t\t\t\t|| testPoint(testRect.right, testRect.top)\n\t\t\t\t\t\t\t|| testPoint(testRect.left, testRect.bottom)\n\t\t\t\t\t\t\t|| testPoint(testRect.right, testRect.bottom);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"rect\": {\n\t\t\t\t\t\tconst rect = (this as any)._getRectShape(direction, distance, true);\n\t\t\t\t\t\tif (rect instanceof PIXI.Polygon) {\n\t\t\t\t\t\t\tcontains = this.shape.contains(testX - this.document.x, testY - this.document.y);\n\t\t\t\t\t\t\tif (contains || TemplateConfig.config.rect === HighlightMode.CENTER) break;\n\t\t\t\t\t\t\t/* Rectangle vertex data order\n\t\t\t\t\t\t\t\tA1───▶B1\n\t\t\t\t\t\t\t\t▲      │\n\t\t\t\t\t\t\t\t│      ▼\n\t\t\t\t\t\t\t\tA2◀───B2\n\t\t\t\t\t\t\t*/\n\t\t\t\t\t\t\t// Translate points to the position of the MeasuredTemplate and map the points to the dataset\n\t\t\t\t\t\t\t[ax1, ay1, bx1, by1, bx2, by2, ax2, ay2] = rect.points.map((e, i) => e + (i % 2 ? this.document.y : this.document.x));\n\t\t\t\t\t\t\t// check the top line\n\t\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax1, ay1, bx1, by1, testRect)\n\t\t\t\t\t\t\t\t// check the right line\n\t\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(bx1, by1, bx2, by2, testRect)\n\t\t\t\t\t\t\t\t// check the bottom line\n\t\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(bx2, by2, ax2, ay2, testRect)\n\t\t\t\t\t\t\t\t// check the left line\n\t\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax2, ay2, ax1, ay1, testRect);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trect.x += this.document.x;\n\t\t\t\t\t\t\trect.y += this.document.y;\n\t\t\t\t\t\t\t// The normalized rectangle always adds 1 to the width and height\n\t\t\t\t\t\t\trect.width -= 1;\n\t\t\t\t\t\t\trect.height -= 1;\n\t\t\t\t\t\t\t// Standard 2D Box Collision detection\n\t\t\t\t\t\t\tcontains = !(rect.left >= testRect.right || rect.right <= testRect.left\n\t\t\t\t\t\t\t\t|| rect.top >= testRect.bottom || rect.bottom <= testRect.top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"cone\": {\n\t\t\t\t\t\tcontains = this.shape.contains(testX - this.document.x, testY - this.document.y);\n\t\t\t\t\t\tif (contains || TemplateConfig.config.cone === HighlightMode.CENTER) break;\n\t\t\t\t\t\tgenerateConeData();\n\t\t\t\t\t\t// check the top line\n\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax1, ay1, bx1, by1, testRect);\n\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t// check the bottom line\n\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax2, ay2, bx2, by2, testRect);\n\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t// check the end-cap\n\t\t\t\t\t\tif (isRound) {\n\t\t\t\t\t\t\tconst sqrDistance = distance * distance;\n\t\t\t\t\t\t\tlet [vx, vy] = [0, 0];\n\t\t\t\t\t\t\tlet mag = 0;\n\t\t\t\t\t\t\tlet vecAngle = 0;\n\t\t\t\t\t\t\tconst testPoint = (x: number, y: number) => {\n\t\t\t\t\t\t\t\t[vx, vy] = [x - this.document.x, y - this.document.y];\n\t\t\t\t\t\t\t\treturn (vx * vx + vy * vy) < sqrDistance;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst testAngle: () => boolean = () => {\n\t\t\t\t\t\t\t\t// calculate vector magnitude\n\t\t\t\t\t\t\t\tmag = Math.sqrt(vx * vx + vy * vy);\n\t\t\t\t\t\t\t\t// normalize the vector\n\t\t\t\t\t\t\t\tvx /= mag;\n\t\t\t\t\t\t\t\t// Calculate the vector's angle, adjusting for bottom hemisphere if Y is negative\n\t\t\t\t\t\t\t\tvecAngle = Math.acos(vx);\n\t\t\t\t\t\t\t\tif (vy < 0) vecAngle = (Math.PI * 2) - vecAngle;\n\t\t\t\t\t\t\t\tconst minAngle = direction - (angle / 2);\n\t\t\t\t\t\t\t\tconst maxAngle = direction + (angle / 2);\n\t\t\t\t\t\t\t\tif (minAngle < 0)\n\t\t\t\t\t\t\t\t\treturn vecAngle <= maxAngle || vecAngle >= ((Math.PI * 2) + minAngle);\n\t\t\t\t\t\t\t\telse if (maxAngle > Math.PI * 2)\n\t\t\t\t\t\t\t\t\treturn vecAngle <= (maxAngle - (Math.PI * 2)) || vecAngle >= minAngle;\n\t\t\t\t\t\t\t\telse return vecAngle <= maxAngle && vecAngle >= minAngle;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (testPoint(testRect.left, testRect.top)) {\n\t\t\t\t\t\t\t\tcontains = testAngle();\n\t\t\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (testPoint(testRect.right, testRect.top)) {\n\t\t\t\t\t\t\t\tcontains = testAngle();\n\t\t\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (testPoint(testRect.left, testRect.bottom)) {\n\t\t\t\t\t\t\t\tcontains = testAngle();\n\t\t\t\t\t\t\t\tif (contains) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (testPoint(testRect.right, testRect.bottom)) {\n\t\t\t\t\t\t\t\tcontains = testAngle();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(bx1, by1, bx2, by2, testRect);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase \"ray\": {\n\t\t\t\t\t\tcontains = this.shape.contains(testX - this.document.x, testY - this.document.y);\n\t\t\t\t\t\tif (contains || TemplateConfig.config.ray === HighlightMode.CENTER) break;\n\t\t\t\t\t\tgenerateRayData();\n\t\t\t\t\t\t// check the top line\n\t\t\t\t\t\tcontains = LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax1, ay1, bx1, by1, testRect)\n\t\t\t\t\t\t\t// check the bottom line\n\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax2, ay2, bx2, by2, testRect)\n\t\t\t\t\t\t\t// check the left endcap line\n\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(ax1, ay1, ax2, ay2, testRect)\n\t\t\t\t\t\t\t// check the right endcap line\n\t\t\t\t\t\t\t|| LineToBoxCollision.cohenSutherlandLineClipAndDraw(bx1, by1, bx2, by2, testRect);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!DEBUG && !contains) continue;\n\t\t\t\ttry { grid.grid.highlightGridPosition(hl, { x: gx, y: gy, border, color: DEBUG ? (contains ? 0x00FF00 : 0xFF0000) : color }); }\n\t\t\t\tcatch (error) {\n\t\t\t\t\t// Catches a specific \"highlight\" error that will randomly occur inside of `grid.grid.highlightGridPosition()`\n\t\t\t\t\tif (!(error instanceof Error) || !error.message.includes(\"'highlight'\")) throw error;\n\t\t\t\t}\n\t\t\t\tif (!contains) continue;\n\n\t\t\t\t// Ignore changing the target selection if we don't own the template, or `shouldAutoSelect` is false\n\t\t\t\tif ((!this.hover && this.id) || !isOwner || !shouldAutoSelect) continue;\n\n\t\t\t\t// If we are using Point based targetting for this template\n\t\t\t\tif (TemplateConfig.config[this.document.t] === HighlightMode.POINTS) {\n\t\t\t\t\tTemplateTargeting._selectTokensByPointContainment.bind(this)(isOwner, shouldAutoSelect, this.document, <PIXI.Polygon>this.shape, true);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Iterate over all existing tokens and target the ones within the template area\n\t\t\t\tfor (const token of canvas.tokens.placeables) {\n\t\t\t\t\tconst tokenRect = new PIXI.Rectangle(token.x, token.y, token.w, token.h).normalize();\n\t\t\t\t\tif (testRect.left >= tokenRect.right || testRect.right <= tokenRect.left\n\t\t\t\t\t\t|| testRect.top >= tokenRect.bottom || testRect.bottom <= tokenRect.top) continue;\n\t\t\t\t\ttoken.setTarget(true, { user: game.user, releaseOthers: false, groupSelection: true });\n\t\t\t\t}\n\t\t\t\t/****** END OF CODE EDIT ******/\n\t\t\t}\n\t\t}\n\t\t/******************************************** END OF COPIED CODE ********************************************/\n\t}\n\n\tprivate static _selectTokensByPointContainment(this: MeasuredTemplate, isOwner: boolean, shouldAutoSelect: boolean, data: { x: number, y: number }, shape: PIXI.Polygon, useMultiPointTest: boolean = false) {\n\t\t//* THIS CODE WAS ORIGINALLY COPIED FROM `MeasuredTemplate.prototype.highlightGrid`\n\t\t// Ignore changing the target selection if we don't own the template, or `shouldAutoSelect` is false\n\t\tif (!isOwner || !shouldAutoSelect) return;\n\n\t\tconst DebugMode = SETTINGS.get<boolean>('template-debug');\n\t\tTemplateTargeting.PointGraphContainer.clear();\n\t\tTemplateTargeting.PointGraphContainer.removeChildren();\n\t\tlet pointGraphics: PIXI.Graphics;\n\t\tif (DebugMode) {\n\t\t\tpointGraphics = new PIXI.Graphics();\n\t\t\tTemplateTargeting.PointGraphContainer.addChild(pointGraphics);\n\t\t}\n\t\t// If we are multi-point grab the gridless resolution, otherwise we test for each grid square center\n\t\tconst pointResolution = useMultiPointTest ? SETTINGS.get<number>(TemplateTargeting.GRIDLESS_RESOLUTION_PREF) : 1;\n\t\t// Iterate over all existing tokens and target the ones within the template area\n\t\tfor (const token of canvas.tokens.placeables) {\n\t\t\t// Get the center offset of the token\n\t\t\tconst hx = token.w / 2;\n\t\t\tconst hy = token.h / 2;\n\t\t\t// Adjust the token position to be relative to the template\n\t\t\tconst [tokenX, tokenY] = [token.x - data.x, token.y - data.y];\n\t\t\t// Calculate how many points there should be along the X and Y axes\n\t\t\tlet horPoints = pointResolution > 1 ? Math.roundDecimals(token.w / canvas.grid.w, 1) * (pointResolution - 1) + 1 : Math.ceil(token.w / canvas.grid.w);\n\t\t\tlet verPoints = pointResolution > 1 ? Math.roundDecimals(token.h / canvas.grid.h, 1) * (pointResolution - 1) + 1 : Math.ceil(token.h / canvas.grid.h);\n\t\t\t// Make a small adjustment for tokens smaller than 1x1\n\t\t\tif (token.w / canvas.grid.w < 1) horPoints = Math.floor(horPoints);\n\t\t\tif (token.h / canvas.grid.h < 1) verPoints = Math.floor(verPoints);\n\t\t\t// Calculate the distance between each point on the vertical and horizontal\n\t\t\tconst horStep = horPoints > 1 ? token.w / (horPoints - 1) : token.w;\n\t\t\tconst verStep = verPoints > 1 ? token.h / (verPoints - 1) : token.h;\n\t\t\t// Generate the points relative to the token position\n\t\t\tlet x = 0;\n\t\t\tlet y = 0;\n\t\t\tlet pointFound = false;\n\t\t\tif (DebugMode) pointGraphics.beginFill(0xFF0000);\n\t\t\tconst percentage = SETTINGS.get<number>(TemplateTargeting.GRIDLESS_PERCENTAGE_PREF) / 100;\n\t\t\tconst pointCount = verPoints * horPoints;\n\t\t\tlet hitCount = 0;\n\t\t\tfor (let row = 0; !pointFound && row < verPoints; row++) {\n\t\t\t\tfor (let col = 0; col < horPoints; col++) {\n\t\t\t\t\tif (pointResolution > 1) {\n\t\t\t\t\t\tx = horPoints > 1 ? tokenX + (horStep * col) : tokenX + hx;\n\t\t\t\t\t\ty = verPoints > 1 ? tokenY + (verStep * row) : tokenY + hy;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tx = horPoints > 1 ? tokenX + (canvas.grid.w * col) + (canvas.grid.w / 2) : tokenX + hx;\n\t\t\t\t\t\ty = verPoints > 1 ? tokenY + (canvas.grid.h * row) + (canvas.grid.h / 2) : tokenY + hy;\n\t\t\t\t\t}\n\t\t\t\t\tif (DebugMode) pointGraphics.drawCircle(x + data.x, y + data.y, 3);\n\t\t\t\t\t// If the point is not contained in the shape, ignore it\n\t\t\t\t\tif (!shape.contains(x, y)) continue;\n\t\t\t\t\t// Increment our hit count for percentage based targetting\n\t\t\t\t\thitCount++;\n\t\t\t\t\t// If we target on touch or hit our required percentage\n\t\t\t\t\tif (percentage === 0 || Math.roundDecimals(hitCount / pointCount, 1) >= percentage) {\n\t\t\t\t\t\t// Mark the token as selected\n\t\t\t\t\t\ttoken.setTarget(true, { user: game.user, releaseOthers: false, groupSelection: true });\n\t\t\t\t\t\tif (!DebugMode) {\n\t\t\t\t\t\t\tpointFound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (DebugMode) pointGraphics.endFill();\n\t\t}\n\t}\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import SETTINGS from \"../../common/Settings\";\nimport AngleSnaps from \"./AngleSnaps\";\nimport SnapIntersect from \"./SnapIntersect\";\nimport SquareTemplate from \"./SquareTemplate\";\nimport TemplateTargeting from \"./TemplateTargeting\";\n\nSETTINGS.init('df-templates');\n\nHooks.once('init', function () {\n\tTemplateTargeting.init();\n\tSnapIntersect.init();\n\tAngleSnaps.init();\n\tSquareTemplate.init();\n\n\t// DEBUG SETTINGS\n\tSETTINGS.register('template-debug', {\n\t\tconfig: true,\n\t\tscope: 'client',\n\t\tname: 'DF_TEMPLATES.DebugName',\n\t\thint: 'DF_TEMPLATES.DebugHint',\n\t\ttype: Boolean,\n\t\tdefault: false\n\t});\n});\n\nHooks.once('ready', function () {\n\tif (!game.modules.get('lib-wrapper')?.active) {\n\t\tconsole.error('Missing libWrapper module dependency');\n\t\tif (game.user.isGM)\n\t\t\tui.notifications.error(game.i18n.localize('DF-QOL.errorLibWrapperMissing'));\n\t\treturn;\n\t}\n\tTemplateTargeting.ready();\n\tSnapIntersect.ready();\n\tAngleSnaps.ready();\n\n\tif ((game as any).dnd5e) {\n\t\tlibWrapper.register(SETTINGS.MOD_NAME, 'game.dnd5e.canvas.AbilityTemplate.prototype.activatePreviewListeners',\n\t\t\tfunction (this: any, wrapper: (il: any) => any, initialLayer: CanvasLayer) {\n\t\t\t\tthis._onMovePlacement_ORIG = this._onMovePlacement;\n\t\t\t\tthis._onMovePlacement = SnapIntersect.handleDnD5eAbilityTemplate.bind(this);\n\t\t\t\tthis._onRotatePlacement_ORIG = this._onRotatePlacement;\n\t\t\t\tthis._onRotatePlacement = AngleSnaps.handleDnD5eAbilityTemplate.bind(this);\n\t\t\t\treturn wrapper(initialLayer);\n\t\t\t}, 'WRAPPER');\n\t}\n});\n"],"names":["SETTINGS","static","moduleName","this","MOD_NAME","String","prototype","localize","game","i18n","valueOf","key","config","settings","register","registerMenu","get","value","set","default","Object","AngleSnaps","scope","name","hint","type","Number","range","min","max","step","libWrapper","event","template","hover","snap","shiftKey","sign","Math","deltaY","delta","direction","document","rotate","ctrlKey","preventDefault","stopPropagation","updateSource","refresh","OutCode","LineToBoxCollision","x","y","bounds","code","INSIDE","left","LEFT","right","RIGHT","top","BOTTOM","bottom","TOP","x0","y0","x1","y1","outcode0","_computeOutCode","outcode1","accept","outcodeOut","SnapIntersect","Boolean","onChange","toggled","patch","unpatch","TemplateLayer_gridPrecision","unregister","canvas","grid","CONST","GRID_TYPES","GRIDLESS","now","Date","_moveTime","center","data","getLocalPosition","layer","snapped","getSnappedPosition","SquareTemplate","FIX_ROTATION_PREF","MeasuredTemplate_getRectShape","MeasuredTemplate_refreshRulerText","distance","adjustForRoundingError","matrix","PIXI","Matrix","IDENTITY","PI","EPSILON","size","sqrt","topLeft","apply","Point","topRight","botLeft","botRight","shape","Polygon","width","height","wrapped","t","text","toFixed","scene","units","ruler","HighlightMode","TemplateConfig","FormApplication","options","_options","root","translations","_fallback","keys","map","defaultOptions","mergeObject","super","resizable","submitOnChange","closeOnSubmit","editable","submitOnClose","popOut","minimizable","title","CONFIG_PREF","isNotDefault","circle","CENTER","cone","rect","ray","PATCH_5E_PREF","PATCH_5E_CIRCLE_PREF","old5ePatch","old5eCirclePatch","TOUCH","templates","placeables","filter","forEach","draw","restricted","label","getData","activateListeners","html","find","on","e","val","close","async","_event","formData","TemplateTargeting","TARGETING_TOGGLE_PREF","TARGETING_MODE_PREF","choices","never","toggle","always","ui","controls","initialize","render","GRIDLESS_RESOLUTION_PREF","GRIDLESS_PERCENTAGE_PREF","PREVIEW_PREF","Hooks","tools","splice","icon","visible","active","onClick","_MeasuredTemplate_highlightGrid","wrapper","MeasuredTemplate","manager","callbacks","dragLeftCancel","PlaceableObject","_onDragLeftCancel","ThrottledTemplateRefresh","throttle","fn","threshhold","last","mostRecent","hasTimer","args","context","setTimeout","dnd5e","handleTemplateCreation","getHighlightLayer","clear","addChild","PointGraphContainer","mode","shouldAutoSelect","isOwner","user","id","userId","tokens","objects","targets","setTarget","releaseOthers","groupSelection","_handleTouchTemplate","bind","points","radius","shapeBounds","MAX_VALUE","MIN_VALUE","c","length","snappedTopLeft","snappedBottomRight","d","dimensions","border","borderColor","color","fillColor","DEBUG","highlightId","hl","clone","p","i","error","highlightGridPosition","_selectTokensByPointContainment","_calculateGridTestArea","colCount","ceil","w","rowCount","h","tx","ty","getTopLeft","row0","col0","getGridPositionFromPixels","hx","hy","angle","toRadians","isRound","rayLength","sin","ax1","ay1","bx1","by1","ax2","ay2","bx2","by2","coneInitialized","generateConeData","cos","generateRayData","r","gx","gy","getPixelsFromGridPosition","testX","testY","testRect","Rectangle","normalize","contains","rcx","rcy","sqrDistance","vx","vy","testPoint","_getRectShape","mag","vecAngle","testAngle","acos","minAngle","maxAngle","Error","message","includes","token","tokenRect","useMultiPointTest","DebugMode","pointGraphics","removeChildren","Graphics","pointResolution","tokenX","tokenY","horPoints","roundDecimals","verPoints","floor","horStep","verStep","pointFound","beginFill","percentage","pointCount","hitCount","row","col","drawCircle","endFill","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","definition","o","defineProperty","enumerable","obj","prop","hasOwnProperty","call","Symbol","toStringTag","once","modules","console","isGM","notifications","initialLayer","_onMovePlacement_ORIG","_onMovePlacement","_onRotatePlacement_ORIG","_onRotatePlacement"],"sourceRoot":""}